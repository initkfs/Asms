     1                                  ; initkfs, 2018
     2                                  ; Euclidean algorithm implementation
     3                                  ; ---------------------
     4                                  %include "./../lib/sys/sys_exit.inc"
     5                              <1> ; initkfs, 2018
     6                              <1> ; ---------------------
     7                              <1> %macro sys_exit 0-1 0 ;default return code: 0
     8                              <1> 
     9                              <1> %%SYS_EXIT  equ 60 ; sys_exit linux system call, linux 64 
    10                              <1> 
    11                              <1> mov rax, %%SYS_EXIT
    12                              <1> mov rdi, %1 ;%rdi - exit code
    13                              <1> syscall
    14                              <1> 
    15                              <1> %endmacro
    16                                  %include "./../lib/sys/sys_readin.inc"
    17                              <1> ; initkfs, 2018
    18                              <1> ; ---------------------
    19                              <1> %macro sys_readin 2 ; 1 - buffer with result, 2 - buffer char size, buffer is variable
    20                              <1> 
    21                              <1> %%SYS_READ equ 0 ; linux sys_read, rax: 0, rdi: unsigned int fd, rsi: char *buf , rdx: size_t count
    22                              <1> %%STDIN    equ 0 ; linux stdin, 0
    23                              <1> 
    24                              <1> push rax
    25                              <1> push rdi
    26                              <1> push rsi
    27                              <1> push rdx
    28                              <1> 
    29                              <1> mov rax, %%SYS_READ
    30                              <1> mov rdi, %%STDIN
    31                              <1> mov rsi, %1 ; buffer
    32                              <1> mov rdx, %2 ; buffer char size
    33                              <1>   
    34                              <1> syscall
    35                              <1> 
    36                              <1> pop rdx
    37                              <1> pop rsi
    38                              <1> pop rdi
    39                              <1> pop rax
    40                              <1> 
    41                              <1> %endmacro
    42                                  %include "./../lib/sys/sys_write.inc"
    43                              <1> ; initkfs, 2018
    44                              <1> ; ---------------------
    45                              <1> %macro sys_write 1-2 -1; 1 - target string, only chars not a number, 2 - string size
    46                              <1> ; default -1, string length autocalculated
    47                              <1> 
    48                              <1> %%SYS_WRITE   equ 1 ; linux sys_write, 64bit
    49                              <1> %%STDOUT      equ 1 ; stdout
    50                              <1> %%STRING_END  equ 0 ; null-byte
    51                              <1> 
    52                              <1> push rax
    53                              <1> push rdi
    54                              <1> push rsi
    55                              <1> push rdx
    56                              <1> 
    57                              <1> mov rsi, %1 ; target string
    58                              <1> 
    59                              <1> %if %2 > 0
    60                              <1>     mov rdx, %2 ; string size from the parameter
    61                              <1> %elif %2 = -1 
    62                              <1> 	mov rdi, rsi
    63                              <1>     call str_length ; calculate string size
    64                              <1> 	mov rdx, rax   ; mov string size to the rdx
    65                              <1> %else
    66                              <1>     %error Error: incorrect string length received. Expected positive number.
    67                              <1> %endif 
    68                              <1> 
    69                              <1> mov rax, %%SYS_WRITE
    70                              <1> mov rdi, %%STDOUT
    71                              <1> 
    72                              <1> syscall
    73                              <1> 
    74                              <1> pop rdx
    75                              <1> pop rsi
    76                              <1> pop rdi
    77                              <1> pop rax
    78                              <1> 
    79                              <1> %endmacro
    80                                  %include "./../lib/string/str_printf.inc"
    81                              <1> ; initkfs, 2018
    82                              <1> ; ---------------------
    83                              <1> %macro str_printf 2 ; format, target string
    84                              <1> 
    85                              <1> extern	printf
    86                              <1> 
    87                              <1> ;d or i	Signed decimal integer
    88                              <1> ;u	Unsigned decimal integer
    89                              <1> ;o	Unsigned octal
    90                              <1> ;x	Unsigned hexadecimal integer,	7fa
    91                              <1> ;X	Unsigned hexadecimal integer (uppercase),	7FA
    92                              <1> ;f	Decimal floating point, lowercase,	392.65
    93                              <1> ;F	Decimal floating point, uppercase,	392.65
    94                              <1> ;e	Scientific notation (mantissa/exponent), lowercase,	3.9265e+2
    95                              <1> ;E	Scientific notation (mantissa/exponent), uppercase,	3.9265E+2
    96                              <1> ;g	Use the shortest representation: %e or %f,	392.65
    97                              <1> ;G	Use the shortest representation: %E or %F,	392.65
    98                              <1> ;a	Hexadecimal floating point, lowercase,	-0xc.90fep-2
    99                              <1> ;A	Hexadecimal floating point, uppercase,	-0XC.90FEP-2
   100                              <1> ;c	Character,	a
   101                              <1> ;s	String of characters,	sample
   102                              <1> ;p	Pointer address,	b8000000
   103                              <1> ;n	Nothing printed.
   104                              <1> ;%	A % followed by another % character will write a single % to the stream.	%
   105                              <1> 
   106                              <1> ;Length & Description
   107                              <1> ;l argument is interpreted as a long int or unsigned long int for integer specifiers (i, d, o, u, x and X), and as a wide character or wide character string for specifiers c and s.
   108                              <1> ;h argument is interpreted as a short int or unsigned short int (only applies to integer specifiers: i, d, o, u, x and X).
   109                              <1> ;L argument is interpreted as a long double (only applies to floating point specifiers: e, E, f, g and G).
   110                              <1> 
   111                              <1> push rdi
   112                              <1> push rsi
   113                              <1> push rax
   114                              <1> 
   115                              <1> enter 0,0
   116                              <1> 
   117                              <1> mov rdi, %1 ; string format to rdi, pass VALUE, not a address
   118                              <1> mov rsi, %2 ; target to rsi,  pass VALUE, not a address
   119                              <1> xor rax,rax ; segfault without reset
   120                              <1> call printf
   121                              <1> 
   122                              <1> leave
   123                              <1> 
   124                              <1> pop rax
   125                              <1> pop rsi
   126                              <1> pop rdi
   127                              <1> 
   128                              <1> %endmacro
   129                                  %include "./../lib/num/num_from_string.inc"
   130                              <1> ; initkfs, 2018
   131                              <1> ; ---------------------
   132                              <1> %macro num_from_string 1 ; target string, result in rax
   133                              <1> 
   134                              <1> extern atoi
   135                              <1> 
   136                              <1> push rdi
   137                              <1> 
   138                              <1> mov rdi, %1
   139                              <1> 
   140                              <1> push rbp
   141                              <1> mov rbp,rsp
   142                              <1> call atoi
   143                              <1> leave
   144                              <1> 
   145                              <1> pop rdi
   146                              <1> 
   147                              <1> %endmacro
   148                                  %include "./../lib/string/str_length.inc"
   149                              <1> ;----------------------------------------------
   150                              <1> ; initkfs, 2018
   151                              <1> ; procedure "str_length"
   152                              <1> ; Params: 1 - memory address of string, RDI.
   153                              <1> ;----------------------------------------------
   154                              <1> global str_length
   155                              <1> 
   156                              <1> str_length:
   157                              <1> 	.start:
   158                              <1> 	
   159 00000000 51                  <1> 	push rcx
   160                              <1> 	
   161 00000001 C8000000            <1> 	enter 0, 0
   162                              <1> 	
   163 00000005 4883FF00            <1> 	cmp rdi, 0
   164 00000009 7417                <1> 	je .notfound
   165                              <1> 	
   166 0000000B 4831C0              <1> 	xor rax, rax
   167 0000000E 4831C9              <1> 	xor rcx, rcx
   168                              <1> 	
   169                              <1> .length:
   170 00000011 8A040F              <1>      mov al, byte [rdi + rcx]
   171 00000014 3C00                <1>      cmp al, 0 ; null-byte
   172 00000016 7405                <1>      je .result
   173 00000018 48FFC1              <1>      inc rcx
   174                              <1>      
   175 0000001B EBF4                <1>      jmp .length
   176                              <1> 
   177                              <1> .result:
   178 0000001D 4889C8              <1> 	mov rax, rcx
   179 00000020 EB07                <1> 	jmp .end
   180                              <1> 	
   181                              <1> .notfound:
   182 00000022 48C7C0FFFFFFFF      <1> 	mov rax, -1
   183                              <1> 
   184                              <1> .end:
   185 00000029 C9                  <1> 	leave
   186 0000002A 59                  <1> 	pop rcx
   187 0000002B C3                  <1> 	ret
   188                              <1> ;----------------------------------------------
   189                              <1> ;			procedure "str_length" end
   190                              <1> ;----------------------------------------------
   191                                  
   192                                  section .data
   193 00000000 4743443D256C640A00      resultFormat: db "GCD=%ld", 10, 0
   194 00000009 4E756D626572206D75-     notPositive: db "Number must be positive", 10, 0
   195 00000012 737420626520706F73-
   196 0000001B 69746976650A00     
   197 00000022 4E756D626572206361-     notEmpty: db "Number cannot be empty", 10, 0
   198 0000002B 6E6E6F742062652065-
   199 00000034 6D7074790A00       
   200                                  
   201                                  READ_CHAR_COUNT equ 10
   202                                  
   203                                  section .bss
   204                                  ; buffers for readin
   205 00000000 <res 00000008>          num1: resq 1
   206 00000008 <res 00000008>          num2: resq 1
   207                                  
   208                                  section .text
   209                                  
   210                                  global main
   211                                  
   212                                  main:
   213                                  
   214                                  readFirst:  
   215                                     sys_readin num1, READ_CHAR_COUNT
   216                              <1> 
   217                              <1> %%SYS_READ equ 0
   218                              <1> %%STDIN equ 0
   219                              <1> 
   220 0000002C 50                  <1> push rax
   221 0000002D 57                  <1> push rdi
   222 0000002E 56                  <1> push rsi
   223 0000002F 52                  <1> push rdx
   224                              <1> 
   225 00000030 B800000000          <1> mov rax, %%SYS_READ
   226 00000035 BF00000000          <1> mov rdi, %%STDIN
   227 0000003A 48BE-               <1> mov rsi, %1
   228 0000003C [0000000000000000]  <1>
   229 00000044 BA0A000000          <1> mov rdx, %2
   230                              <1> 
   231 00000049 0F05                <1> syscall
   232                              <1> 
   233 0000004B 5A                  <1> pop rdx
   234 0000004C 5E                  <1> pop rsi
   235 0000004D 5F                  <1> pop rdi
   236 0000004E 58                  <1> pop rax
   237                              <1> 
   238 0000004F 48BF-                      mov rdi, num1
   239 00000051 [0000000000000000] 
   240 00000059 E892000000                 call toNumber
   241 0000005E 48890425[00000000]         mov [num1], rax
   242                                  
   243                                  readSecond:   
   244                                     sys_readin num2, READ_CHAR_COUNT
   245                              <1> 
   246                              <1> %%SYS_READ equ 0
   247                              <1> %%STDIN equ 0
   248                              <1> 
   249 00000066 50                  <1> push rax
   250 00000067 57                  <1> push rdi
   251 00000068 56                  <1> push rsi
   252 00000069 52                  <1> push rdx
   253                              <1> 
   254 0000006A B800000000          <1> mov rax, %%SYS_READ
   255 0000006F BF00000000          <1> mov rdi, %%STDIN
   256 00000074 48BE-               <1> mov rsi, %1
   257 00000076 [0800000000000000]  <1>
   258 0000007E BA0A000000          <1> mov rdx, %2
   259                              <1> 
   260 00000083 0F05                <1> syscall
   261                              <1> 
   262 00000085 5A                  <1> pop rdx
   263 00000086 5E                  <1> pop rsi
   264 00000087 5F                  <1> pop rdi
   265 00000088 58                  <1> pop rax
   266                              <1> 
   267 00000089 48BF-                      mov rdi, num2
   268 0000008B [0800000000000000] 
   269 00000093 E858000000                 call toNumber
   270 00000098 48890425[08000000]         mov [num2], rax
   271                                  
   272                                  leftGreater:
   273 000000A0 488B0425[00000000]          mov rax, [num1]
   274 000000A8 488B0C25[08000000]          mov rcx, [num2]
   275 000000B0 4839C8                      cmp rax, rcx
   276 000000B3 7C02                        jl rightGreater  
   277 000000B5 EB02                        jmp while   
   278                                      
   279                                  rightGreater:
   280 000000B7 4891                        xchg rax, rcx ; swap registers
   281                                  
   282                                  ; now a (rax) = larger number, b (rcx) = smaller number
   283                                  while:
   284 000000B9 4831D2                      xor rdx, rdx	; prevent error from div
   285 000000BC 48F7F1                      div rcx			; rax - result, rcx - remainder
   286 000000BF 4889C8                      mov rax, rcx	; a = b
   287 000000C2 4889D1                      mov rcx, rdx	; b = remainder
   288                                     
   289 000000C5 4883F900                    cmp rcx, 0		; while(b != 0)
   290 000000C9 75EE                        jne while		; 
   291                                   
   292                                  result:   
   293                                      str_printf resultFormat, rax
   294                              <1> 
   295                              <1> extern printf
   296                              <1> 
   297                              <1> 
   298                              <1> 
   299                              <1> 
   300                              <1> 
   301                              <1> 
   302                              <1> 
   303                              <1> 
   304                              <1> 
   305                              <1> 
   306                              <1> 
   307                              <1> 
   308                              <1> 
   309                              <1> 
   310                              <1> 
   311                              <1> 
   312                              <1> 
   313                              <1> 
   314                              <1> 
   315                              <1> 
   316                              <1> 
   317                              <1> 
   318                              <1> 
   319                              <1> 
   320                              <1> 
   321 000000CB 57                  <1> push rdi
   322 000000CC 56                  <1> push rsi
   323 000000CD 50                  <1> push rax
   324                              <1> 
   325 000000CE C8000000            <1> enter 0,0
   326                              <1> 
   327 000000D2 48BF-               <1> mov rdi, %1
   328 000000D4 [0000000000000000]  <1>
   329 000000DC 4889C6              <1> mov rsi, %2
   330 000000DF 4831C0              <1> xor rax,rax
   331 000000E2 E8(00000000)        <1> call printf
   332                              <1> 
   333 000000E7 C9                  <1> leave
   334                              <1> 
   335 000000E8 58                  <1> pop rax
   336 000000E9 5E                  <1> pop rsi
   337 000000EA 5F                  <1> pop rdi
   338                              <1> 
   339 000000EB E985000000                  jmp end
   340                                  
   341                                  toNumber:
   342 000000F0 803F0A                     cmp byte [rdi], 10 ; check value is not empty
   343 000000F3 7535                       jne .convertNumber
   344                                     sys_write notEmpty
   345                              <1> 
   346                              <1> 
   347                              <1> %%SYS_WRITE equ 1
   348                              <1> %%STDOUT equ 1
   349                              <1> %%STRING_END equ 0
   350                              <1> 
   351 000000F5 50                  <1> push rax
   352 000000F6 57                  <1> push rdi
   353 000000F7 56                  <1> push rsi
   354 000000F8 52                  <1> push rdx
   355                              <1> 
   356 000000F9 48BE-               <1> mov rsi, %1
   357 000000FB [2200000000000000]  <1>
   358                              <1> 
   359                              <1> %if %2 > 0
   360                              <1>  mov rdx, %2
   361                              <1> %elif %2 = -1
   362 00000103 4889F7              <1>  mov rdi, rsi
   363 00000106 E8F5FEFFFF          <1>  call str_length
   364 0000010B 4889C2              <1>  mov rdx, rax
   365                              <1> %else
   366                              <1>  %error Error: incorrect string length received. Expected positive number.
   367                              <1> %endif
   368                              <1> 
   369 0000010E B801000000          <1> mov rax, %%SYS_WRITE
   370 00000113 BF01000000          <1> mov rdi, %%STDOUT
   371                              <1> 
   372 00000118 0F05                <1> syscall
   373                              <1> 
   374 0000011A 5A                  <1> pop rdx
   375 0000011B 5E                  <1> pop rsi
   376 0000011C 5F                  <1> pop rdi
   377 0000011D 58                  <1> pop rax
   378                              <1> 
   379                                     sys_exit 1
   380                              <1> 
   381                              <1> %%SYS_EXIT equ 60
   382                              <1> 
   383 0000011E B83C000000          <1> mov rax, %%SYS_EXIT
   384 00000123 BF01000000          <1> mov rdi, %1
   385 00000128 0F05                <1> syscall
   386                              <1> 
   387                                     
   388                                  .convertNumber:
   389                                     num_from_string rdi
   390                              <1> 
   391                              <1> extern atoi
   392                              <1> 
   393 0000012A 57                  <1> push rdi
   394                              <1> 
   395 0000012B 4889FF              <1> mov rdi, %1
   396                              <1> 
   397 0000012E 55                  <1> push rbp
   398 0000012F 4889E5              <1> mov rbp,rsp
   399 00000132 E8(00000000)        <1> call atoi
   400 00000137 C9                  <1> leave
   401                              <1> 
   402 00000138 5F                  <1> pop rdi
   403                              <1> 
   404 00000139 4883F800                   cmp rax, 0 ; check value is larger then zero
   405 0000013D 7F35                       jg .returnNumber
   406                                     sys_write notPositive
   407                              <1> 
   408                              <1> 
   409                              <1> %%SYS_WRITE equ 1
   410                              <1> %%STDOUT equ 1
   411                              <1> %%STRING_END equ 0
   412                              <1> 
   413 0000013F 50                  <1> push rax
   414 00000140 57                  <1> push rdi
   415 00000141 56                  <1> push rsi
   416 00000142 52                  <1> push rdx
   417                              <1> 
   418 00000143 48BE-               <1> mov rsi, %1
   419 00000145 [0900000000000000]  <1>
   420                              <1> 
   421                              <1> %if %2 > 0
   422                              <1>  mov rdx, %2
   423                              <1> %elif %2 = -1
   424 0000014D 4889F7              <1>  mov rdi, rsi
   425 00000150 E8ABFEFFFF          <1>  call str_length
   426 00000155 4889C2              <1>  mov rdx, rax
   427                              <1> %else
   428                              <1>  %error Error: incorrect string length received. Expected positive number.
   429                              <1> %endif
   430                              <1> 
   431 00000158 B801000000          <1> mov rax, %%SYS_WRITE
   432 0000015D BF01000000          <1> mov rdi, %%STDOUT
   433                              <1> 
   434 00000162 0F05                <1> syscall
   435                              <1> 
   436 00000164 5A                  <1> pop rdx
   437 00000165 5E                  <1> pop rsi
   438 00000166 5F                  <1> pop rdi
   439 00000167 58                  <1> pop rax
   440                              <1> 
   441                                     sys_exit 1
   442                              <1> 
   443                              <1> %%SYS_EXIT equ 60
   444                              <1> 
   445 00000168 B83C000000          <1> mov rax, %%SYS_EXIT
   446 0000016D BF01000000          <1> mov rdi, %1
   447 00000172 0F05                <1> syscall
   448                              <1> 
   449                                  .returnNumber:
   450 00000174 C3                         ret
   451                                  
   452                                  end:
   453                                  sys_exit
   454                              <1> 
   455                              <1> %%SYS_EXIT equ 60
   456                              <1> 
   457 00000175 B83C000000          <1> mov rax, %%SYS_EXIT
   458 0000017A BF00000000          <1> mov rdi, %1
   459 0000017F 0F05                <1> syscall
   460                              <1> 
